<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TileList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lawnlayer</a> &gt; <a href="index.source.html" class="el_package">lawnlayer</a> &gt; <span class="el_source">TileList.java</span></div><h1>TileList.java</h1><pre class="source lang-java linenums">package lawnlayer;

import java.util.ArrayList;
import java.util.List;

import lawnlayer.Info.Name;
import processing.core.PApplet;
import processing.core.PImage;

/**
 * A class acting as a container for the Tile objects. Its data structure
 * and behaviours are essentially a combination of a List and a Set: an
 * ordered collection of unique objects that supports random access and
 * indexing. In addition, this class provides methods to perform game
 * mechanics on these tiles such such as filling regions, propagating
 * red paths, removing collided tiles, etc.
 */
public class TileList {

    /**
     * The number of frames per red path propagation.
     */
    private static final int FPP = 3;

    private List&lt;Tile&gt; tiles;
    private Name tileName;
    private PImage tileSprite;

    /**
     * Initialises an empty TileList with no specified name nor sprite
     * of the tiles to be contained inside it.
     */
<span class="fc" id="L33">    public TileList() {</span>

<span class="fc" id="L35">        tiles = new ArrayList&lt;&gt;();</span>
        
<span class="fc" id="L37">        tileName = Name.UNNAMED;</span>
<span class="fc" id="L38">        tileSprite = null;</span>
<span class="fc" id="L39">    }</span>
    
    /**
     * Initialises an empty TileList with the specified tileSprite and
     * tileName of the tiles to be contained inside it.
     * 
     * @param tileSprite the PImage sprite of the tiles to be contained
     * @param tileName the name of the tiles to be contained
     */
<span class="fc" id="L48">    public TileList(PImage tileSprite, Name tileName) {</span>

<span class="fc" id="L50">        tiles = new ArrayList&lt;&gt;();</span>
        
<span class="fc" id="L52">        this.tileName = tileName;</span>
<span class="fc" id="L53">        this.tileSprite = tileSprite;</span>
<span class="fc" id="L54">    }</span>
    
    /**
     * Initialises a TileList containing the tiles inside the specified
     * Tile array.
     * 
     * @param tiles the Tile array of tiles to be added
     */
<span class="fc" id="L62">    public TileList(Tile[] tiles) {</span>

<span class="fc" id="L64">        this.tiles = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L66" title="All 2 branches covered.">        for (Tile tile : tiles)</span>
<span class="fc" id="L67">            this.tiles.add(tile);</span>

<span class="fc" id="L69">        tileName = Name.UNNAMED;</span>
<span class="fc" id="L70">        tileSprite = null;</span>
<span class="fc" id="L71">    }</span>

    /**
     * Adds the specified tile into this TileList, if such tile does not
     * already exist.
     * 
     * @param tile the tile to be added
     * @return true if the tile has been successfully added
     * 
     * @see List#add(Object)
     */
    public boolean add(Tile tile) {
        
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (!tiles.contains(tile)) {</span>
<span class="fc" id="L85">            tiles.add(tile);</span>
<span class="fc" id="L86">            return true;</span>
        }
<span class="fc" id="L88">        return false;</span>
    }

    /**
     * Adds all of the tiles inside the specified otherTiles into
     * this TileList. For each tile, if it already exists in this
     * TileList, skips and does not add it.
     * 
     * @param otherTiles the TileList of tiles to be added
     * @return true if all tiles have been successfully added
     * 
     * @see #add(Tile)
     */
    public boolean addAll(TileList otherTiles) {

<span class="fc" id="L103">        boolean allTilesAreAdded = true;</span>

<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (Tile tile : otherTiles.toList()) {</span>
            
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (!this.add(tile))</span>
<span class="fc" id="L108">                allTilesAreAdded = false;</span>
<span class="fc" id="L109">        }</span>
<span class="fc" id="L110">        return allTilesAreAdded;</span>
    }

    /**
     * Clears this TileList.
     * 
     * @see List#clear()
     */
    public void clear() {

<span class="fc" id="L120">        tiles.clear();</span>
<span class="fc" id="L121">    }</span>

    /**
     * Checks if the specified positionTile is contained in this TileList.
     * 
     * @param positionTile the Tile to be checked against for containment
     * @return true if this TileList contains the specified positionTile
     * 
     * @see List#contains(Object)
     */
    public boolean contains(Tile positionTile) {

<span class="fc" id="L133">        return tiles.contains(positionTile);</span>
    }

    /**
     * Draws the tiles in this TileList.
     * 
     * @param app the PApplet instance to be drawn in
     * 
     * @see GameObject#draw(PApplet)
     */
    public void drawTiles(PApplet app) {

<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (Tile tile : tiles)</span>
<span class="nc" id="L146">            tile.draw(app);</span>
<span class="nc" id="L147">    }</span>

    /**
     * Fills the regions enclosed on two sides of this TileList,
     * if there are no enemies within them.
     * &lt;p&gt;
     * Retrieves the starting tiles for the first and second region
     * respectively. Then, fills the first and second region into two
     * TileLists. For each region, checks if there are enemies within
     * it, and clears the corresponding TileList if there is at least
     * one. Finally, updates the grass fill tiles by adding in the
     * region TileLists, and updates the unfilled tiles by removing
     * tiles that are contained in the region TileLists.
     * 
     * @param borderTiles the TileList of grass border tiles
     * @param unfilledTiles the TileList of unfilled tiles
     * @param fillTiles the TileList of grass fill tiles
     * @param concreteTiles the TileList of concrete tiles
     * @param enemies the List of enemies
     * @param printMsg toggles fill messages printed in the terminal
     * 
     * @see #convertToFillTiles(TileList)
     * @see #getStartTiles(TileList, TileList)
     * @see #fillRegion(Tile, TileList, TileList, PImage)
     * @see Enemy#isOverlapping(GameObject)
     */
    public void fill(TileList borderTiles, TileList unfilledTiles,
        TileList fillTiles, TileList concreteTiles, List&lt;Enemy&gt; enemies,
        boolean printMsg) {

<span class="fc" id="L177">        long before = System.currentTimeMillis();</span>

<span class="fc" id="L179">        Tile firstStartTile =</span>
<span class="fc" id="L180">            getStartTiles(borderTiles, concreteTiles).get(0);</span>
<span class="fc" id="L181">        Tile secondStartTile =</span>
<span class="fc" id="L182">            getStartTiles(borderTiles, concreteTiles).get(1);</span>
        
<span class="fc" id="L184">        TileList firstRegion =</span>
<span class="fc" id="L185">            fillRegion(firstStartTile, borderTiles, concreteTiles,</span>
<span class="fc" id="L186">                fillTiles.getTileSprite());</span>
<span class="fc" id="L187">        TileList secondRegion =</span>
<span class="fc" id="L188">            fillRegion(secondStartTile, borderTiles, concreteTiles,</span>
<span class="fc" id="L189">                fillTiles.getTileSprite());</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (Enemy enemy : enemies) {</span>

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (enemy.isOverlapping(firstRegion))</span>
<span class="nc" id="L194">                firstRegion.clear();</span>
            
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (enemy.isOverlapping(secondRegion))</span>
<span class="fc" id="L197">                secondRegion.clear();</span>
<span class="fc" id="L198">        }</span>
<span class="fc" id="L199">        fillTiles.addAll(firstRegion);</span>
<span class="fc" id="L200">        fillTiles.addAll(secondRegion);</span>

<span class="fc" id="L202">        unfilledTiles.removeAll(firstRegion);</span>
<span class="fc" id="L203">        unfilledTiles.removeAll(secondRegion);</span>
<span class="fc" id="L204">        unfilledTiles.removeAll(this);</span>

<span class="fc" id="L206">        borderTiles.convertToFillTiles(this);</span>

<span class="fc" id="L208">        long after = System.currentTimeMillis();</span>

<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (printMsg) {</span>
<span class="nc" id="L211">            int totalFilled =</span>
<span class="nc" id="L212">                this.size() + firstRegion.size() + secondRegion.size();</span>
<span class="nc" id="L213">            System.out.printf(&quot;Filling took %d ms, filled %d tiles, &quot; +</span>
<span class="nc" id="L214">                &quot;%d unfilled tiles remaining%n&quot;, (after - before),</span>
<span class="nc" id="L215">                totalFilled, unfilledTiles.size());</span>
        }
<span class="fc" id="L217">    }</span>

    /**
     * Retrieves the tile of the specified index in this TileList.
     * 
     * @param index the index of the tile to be retrieved
     * @return the retrieved tile
     * 
     * @see List#get(int)
     */
    public Tile get(int index) {

<span class="fc" id="L229">        return tiles.get(index);</span>
    }

    /**
     * Attempts to retrieve the tile in the TileList equals to specified
     * positionTile.
     * 
     * @param positionTile the tile to be retrieved
     * @return the specified tile inside this TileList if such tile exists,
     * null otherwise
     * 
     * @see Tile#equals(Object)
     */
    public Tile get(Tile positionTile) {

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        for (Tile tile : tiles) {</span>

<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if (tile.equals(positionTile))</span>
<span class="fc" id="L247">                return tile;</span>
<span class="nc" id="L248">        }</span>
<span class="nc" id="L249">        return null;</span>
    }

    /**
     * Retrieves the name of the tiles in this TileList.
     * 
     * @return the name of the tiles
     */
    public Name getTileName() {

<span class="fc" id="L259">        return tileName;</span>
    }

    /**
     * Retrieves the sprite of the tiles in this TileList.
     * 
     * @return the PImage sprite of the tiles
     */
    public PImage getTileSprite() {

<span class="fc" id="L269">        return tileSprite;</span>
    }

    /**
     * Checks whether this TileList is empty.
     * 
     * @return true if this TileList is empty
     * 
     * @see List#isEmpty()
     */
    public boolean isEmpty() {

<span class="fc" id="L281">        return (tiles.isEmpty());</span>
    }

    /**
     * Propagates red path as per the pre-defined FPP (frames per
     * propagation).
     * &lt;p&gt;
     * Loops through this TileList and locates the red path tile.
     * If a red path is found and n frames has passed since the
     * last propagation (where n is the FPP), retrieves its
     * adjacent path tiles and turn them red.
     * 
     * @param redPathSprite the PImage sprite of the red path
     * @param frameCount the current frame
     * 
     * @see Tile#getAdjacentTiles()
     * @see Tile#isRed()
     * @see Tile#turnRed(PImage, int)
     */
    public void propagate(PImage redPathSprite, int frameCount) {

<span class="nc bnc" id="L302" title="All 2 branches missed.">        for (Tile tile : tiles) {</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (tile.isRed() &amp;&amp;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                tile.getFrameOfCollision() != frameCount &amp;&amp;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                (frameCount - tile.getFrameOfCollision())</span>
                % FPP == 0) {
                
<span class="nc" id="L309">                TileList adjacentTiles = tile.getAdjacentTiles();</span>
                
<span class="nc bnc" id="L311" title="All 2 branches missed.">                for (Tile adjacentTile : adjacentTiles.toList()) {</span>

<span class="nc" id="L313">                    Tile adjacentPathTile = this.get(adjacentTile);</span>

<span class="nc bnc" id="L315" title="All 2 branches missed.">                    if (adjacentPathTile != null &amp;&amp;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                        !adjacentPathTile.isRed())</span>
<span class="nc" id="L317">                        adjacentPathTile.turnRed(redPathSprite, frameCount);</span>
<span class="nc" id="L318">                }</span>
            }
<span class="nc" id="L320">        }</span>
<span class="nc" id="L321">    }</span>

    /**
     * Removes the specified tile from this TileList if such tile exists.
     * 
     * @param tile the tile to be removed
     * @return true if the tile has been successfully removed
     * 
     * @see List#remove(Object)
     */
    public boolean remove(Tile tile) {

<span class="fc" id="L333">        return tiles.remove(tile);</span>
    }

    /**
     * Removes all of the tiles in the specified otherTiles
     * from this TileList.
     * 
     * @param otherTiles the TileList of tiles to be removed
     * 
     * @see List#removeAll(java.util.Collection)
     */
    public void removeAll(TileList otherTiles) {

<span class="fc" id="L346">        tiles.removeAll(otherTiles.toList());</span>
<span class="fc" id="L347">    }</span>

    /**
     * Removes any floating tiles in this TileList.
     * &lt;p&gt;
     * A tile is removed if it is floating around
     * this TileList and the specified otherTiles.
     * 
     * @param otherTiles the TileList of tiles to be checked against
     * for floating tiles
     * 
     * @see List#removeIf(java.util.function.Predicate)
     * @see Tile#isFloatingAround(TileList)
     */
    public void removeFloatingTiles(TileList otherTiles) {

<span class="fc" id="L363">        tiles.removeIf(tile -&gt; </span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            (tile.isFloatingAround(this) &amp;&amp;</span>
<span class="pc bnc" id="L365" title="All 2 branches missed.">            tile.isFloatingAround(otherTiles)));</span>
<span class="fc" id="L366">    }</span>

    /**
     * Retrieves the size of this TileList.
     * 
     * @return the size of this TileList
     * 
     * @see List#size()
     */
    public int size() {

<span class="fc" id="L377">        return tiles.size();</span>
    }

    /**
     * Retrieves this TileList as a List. This method is
     * useful for iterating through a TileList.
     * 
     * @return the Java List container of this TileList
     */
    public List&lt;Tile&gt; toList() {

<span class="fc" id="L388">        return tiles;</span>
    }

    /**
     * Retrieves the string representation of this TileList.
     * 
     * @return the string representation of this TileList
     */
    public String toString() {

<span class="fc" id="L398">        return tiles.toString();</span>
    }

    /**
     * Updates the border tiles contained in this TileList whenever a
     * tile has been collided by an Enemy of type Beetle.
     * &lt;p&gt;
     * Loops through the specified fillTiles and locates the tile(s) that
     * are adjacent to the specified collidedTile. Marks those tile(s) for
     * removal from fillTiles and and adds them to this TileList, turning
     * them into new border tiles. Finally, removes the collidedTile from
     * this TileList.
     * 
     * @param collidedTile the border tile which has been collided
     * @param fillTiles the TileList of grass fill tiles
     * 
     * @see Tile#isAdjacentTo(Tile)
     */
    public void updateBorder(Tile collidedTile, TileList fillTiles) {

<span class="fc" id="L418">        TileList toBeRemoved = new TileList();</span>
<span class="fc" id="L419">        Direction orientation = collidedTile.getOrientation();</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (Tile tile : fillTiles.toList()) {</span>

<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (tile.isAdjacentTo(collidedTile)) {</span>
                
<span class="nc" id="L425">                tile.setOrientation(orientation);</span>
<span class="nc" id="L426">                add(tile);</span>
<span class="nc" id="L427">                toBeRemoved.add(tile);</span>
            }
<span class="fc" id="L429">        }</span>
<span class="fc" id="L430">        fillTiles.removeAll(toBeRemoved);</span>
<span class="fc" id="L431">        remove(collidedTile);</span>
<span class="fc" id="L432">    }</span>

    /**
     * Converts the specified TileList (otherTiles) into this
     * TileList's tiles.
     * &lt;p&gt;
     * Loops through the TileList to be converted, and for each tile
     * creates a new tile of the same XY-coordinate but with the
     * sprite and name of this TileList's tiles. Then, adds
     * the new tile to this TileList.
     * 
     * @param otherTiles
     */
    private void convertToFillTiles(TileList otherTiles) {

<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (Tile tile : otherTiles.toList()) {</span>

<span class="fc" id="L449">            Tile newTile = new Tile(tileSprite, tile.getX(),</span>
<span class="fc" id="L450">                tile.getY(), tileName);</span>
<span class="fc" id="L451">            newTile.setOrientation(tile.getOrientation());</span>

<span class="fc" id="L453">            add(newTile);</span>
<span class="fc" id="L454">        }</span>
<span class="fc" id="L455">        otherTiles.clear();</span>
<span class="fc" id="L456">    }</span>

    /**
     * Fills the enclosed region specified by the starting tile.
     * &lt;p&gt;
     * Adds the starting tile as the first tile of the region tiles.
     * Then, loops through the region tiles, and for each tile in
     * the region retrieves the adjacent tiles in all four directions.
     * For each adjacent tile, checks if it is fillable (i.e., it is
     * not a path tile, grass border tile, nor concrete tiles), and
     * adds it to the current region tiles if it is. The region
     * tiles should grow progressively until there are no more
     * adjacent tiles which are fillable, indicating the entire region
     * has been filled.
     * &lt;p&gt;
     * If the starting tile is unnamed (i.e., there was no starting
     * tile found), then there is no region to be filled. Thus,
     * returns an empty TileList.
     * 
     * @param startTile the starting tile for filling the region
     * @param borderTiles the TileList of grass border tiles
     * @param concreteTiles the TileList of concrete tiles
     * @param fillSprite the PImage sprite for the filled region tiles
     * @return a TileList of the filled region tiles
     * 
     * @see Tile#getAdjacentTiles()
     */
    private TileList fillRegion(Tile startTile, TileList borderTiles,
        TileList concreteTiles, PImage fillSprite) {

<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (startTile.getName() == Name.UNNAMED)</span>
<span class="nc" id="L487">            return new TileList();</span>
    
<span class="fc" id="L489">        TileList regionTiles = new TileList(fillSprite, Name.GRASS);</span>
<span class="fc" id="L490">        startTile.setSprite(fillSprite);</span>
<span class="fc" id="L491">        regionTiles.add(startTile);</span>
        
<span class="fc bfc" id="L493" title="All 2 branches covered.">        for (int i = 0; i &lt; regionTiles.size(); i++) {</span>

<span class="fc" id="L495">            Tile tile = regionTiles.get(i);</span>
<span class="fc" id="L496">            TileList adjacentTiles = tile.getAdjacentTiles();</span>

<span class="fc bfc" id="L498" title="All 2 branches covered.">            for (Tile adjacentTile : adjacentTiles.toList()) {</span>

<span class="fc bfc" id="L500" title="All 2 branches covered.">                if (!this.contains(adjacentTile) &amp;&amp;</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">                    !borderTiles.contains(adjacentTile) &amp;&amp;</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">                    !concreteTiles.contains(adjacentTile)) {</span>
                    
<span class="fc" id="L504">                    regionTiles.add(adjacentTile);</span>
                }
<span class="fc" id="L506">            }</span>
        }
<span class="fc" id="L508">        return regionTiles;</span>
    }

    /**
     * Locates the starting tile for filling each of the two regions.
     * &lt;p&gt;
     * Loops through the path tiles, and for each path tile retrieves the
     * adjacent tiles in the directions normal to the path's orientation.
     * If the adjacent tile is clear (i.e., it is not a concrete, path,
     * nor grass border tile), proceeds to set it as the starting tile.
     * 
     * @param borderTiles the TileList of grass border tiles
     * @param concreteTiles the TileList of concrete tiles
     * @return a TileList of starting tiles for each region
     * 
     * @see Direction#normal()
     * @see Direction#flip()
     * @see Tile#getAdjacentTile(Direction)
     */
    private TileList getStartTiles(TileList borderTiles,
        TileList concreteTiles) {

<span class="fc" id="L530">        Tile firstStartTile = new Tile();</span>
<span class="fc" id="L531">        Tile secondStartTile = new Tile();</span>

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        for (Tile tile : tiles) {</span>

<span class="fc" id="L535">            Direction direction = tile.getOrientation();</span>

<span class="fc" id="L537">            Tile firstAdjacentTile =</span>
<span class="fc" id="L538">                tile.getAdjacentTile(direction.normal());</span>
            
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            if (!borderTiles.contains(firstAdjacentTile) &amp;&amp;</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                !concreteTiles.contains(firstAdjacentTile) &amp;&amp;</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                !this.contains(firstAdjacentTile)) {</span>

<span class="fc" id="L544">                firstStartTile = firstAdjacentTile;</span>
<span class="fc" id="L545">                firstStartTile.setName(Name.GRASS);</span>
<span class="fc" id="L546">                break;</span>
            }
<span class="nc" id="L548">        }</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        for (Tile tile : tiles) {</span>

<span class="fc" id="L551">            Direction direction = tile.getOrientation();</span>

<span class="fc" id="L553">            Tile secondAdjacentTile =</span>
<span class="fc" id="L554">                tile.getAdjacentTile(direction.normal().flip());</span>
            
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">            if (!borderTiles.contains(secondAdjacentTile) &amp;&amp;</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                !concreteTiles.contains(secondAdjacentTile) &amp;&amp;</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">                !this.contains(secondAdjacentTile)) {</span>

<span class="fc" id="L560">                secondStartTile = secondAdjacentTile;</span>
<span class="fc" id="L561">                secondStartTile.setName(Name.GRASS);</span>
<span class="fc" id="L562">                break;</span>
            }
<span class="nc" id="L564">        }</span>
<span class="fc" id="L565">        return new TileList(new Tile[] {firstStartTile, secondStartTile});</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>