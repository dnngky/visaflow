<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Enemy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lawnlayer</a> &gt; <a href="index.source.html" class="el_package">lawnlayer</a> &gt; <span class="el_source">Enemy.java</span></div><h1>Enemy.java</h1><pre class="source lang-java linenums">package lawnlayer;

import lawnlayer.Info.Name;
import processing.core.PImage;

/**
 * A subclass of Entity governing the behaviours of all enemy types in
 * the game.
 */
public class Enemy extends Entity {
    
    private Side collidedAt;
    private Tile collidedTile;
    private Movement movement;

    /**
     * Initialises an Enemy with the specified sprite and name. Its
     * XY-coordinate will be randomised within the map bounds.
     * 
     * @param sprite the PImage sprite of the Enemy
     * @param name the name of the Enemy
     * 
     * @see Entity#Entity(PImage, Name)
     */
    public Enemy(PImage sprite, Name name) {
        
<span class="fc" id="L27">        super(sprite, name);</span>

<span class="fc" id="L29">        collidedAt = Side.NONE;</span>
<span class="fc" id="L30">        collidedTile = null;</span>
<span class="fc" id="L31">        initialiseMovement();</span>
<span class="fc" id="L32">    }</span>

    /**
     * Initialises an Enemy with the specified sprite, XY-coordinate,
     * and name.
     * 
     * @param sprite the PImage sprite of the Enemy
     * @param x the x-coordinate of the Enemy
     * @param y the y-coordinate of the Enemy
     * @param name the name of the Enemy
     * 
     * @see Enemy#Enemy(PImage, int, int, Name)
     */
    public Enemy(PImage sprite, int x, int y, Name name) {
        
<span class="fc" id="L47">        super(sprite, x, y, name);</span>

<span class="fc" id="L49">        collidedAt = Side.NONE;</span>
<span class="fc" id="L50">        collidedTile = null;</span>
<span class="fc" id="L51">        initialiseMovement();</span>
<span class="fc" id="L52">    }</span>

    /**
     * Initialises an Enemy with the specified sprite, tile location, and
     * name. Its XY-coordinate will be randomised within the tile location.
     * 
     * @param sprite the PImage sprite of the Enemy
     * @param location the tile location of the Enemy
     * @param name the name of the Enemy
     * 
     * @see Enemy#Enemy(PImage, String, Name)
     */
    public Enemy(PImage sprite, String location, Name name) {
        
<span class="nc" id="L66">        super(sprite, location, name);</span>

<span class="nc" id="L68">        collidedAt = Side.NONE;</span>
<span class="nc" id="L69">        collidedTile = null;</span>
<span class="nc" id="L70">        initialiseMovement();</span>
<span class="nc" id="L71">    }</span>

    /**
     * Checks for any collision of this Enemy with the tiles inside thef
     * specified TileList 'otherTiles' and updates its direction of
     * movement accordingly.
     * &lt;p&gt;
     * Checks for both diagonal (corner) collision and straight (side)
     * collisions with the tiles in 'otherTiles'. If 'otherTiles' are grass
     * border tiles, and the Enemy type is beetle, then update the border
     * tiles.
     * 
     * @param otherTiles the TileList to be checked against for collision
     * with this Enemy
     * @param fillTiles the TileList which will be updated alongside
     * 'otherTiles' if 'otherTiles' are grass borders tiles and Enemy type
     * is beetle
     * @param printMsg toggles collision messages printed in the terminal
     * 
     * @see #checkForDiagonalCollisionWith(TileList)
     * @see #checkForStraightCollisionWith(TileList)
     * @see TileList#updateBorder(Tile, TileList)
     */
    public void checkForCollisionWith(TileList otherTiles, TileList fillTiles,
        boolean printMsg) {
        
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (movement != Movement.STATIONARY)</span>
<span class="fc" id="L98">            checkForDiagonalCollisionWith(otherTiles);</span>
        
<span class="pc bpc" id="L100" title="2 of 4 branches missed.">        if (movement != Movement.STATIONARY &amp;&amp;</span>
            collidedAt == Side.NONE)
<span class="fc" id="L102">            checkForStraightCollisionWith(otherTiles);</span>
        
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        if (collidedAt != Side.NONE &amp;&amp;</span>
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">            collidedTile.getName() == Name.GRASS &amp;&amp;</span>
            name == Name.BEETLE) {
            
<span class="fc" id="L108">            otherTiles.updateBorder(collidedTile, fillTiles);</span>
        }
<span class="pc bpc" id="L110" title="3 of 4 branches missed.">        if (printMsg &amp;&amp; collidedAt != Side.NONE &amp;&amp;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">            collidedTile.getName().equals(otherTiles.getTileName()))</span>

<span class="nc" id="L113">            System.out.printf(&quot;%s collided at %s with %s%n&quot;,</span>
                              this, collidedAt, collidedTile);
<span class="fc" id="L115">    }</span>

    /**
     * Checks if this Enemy has spawned at a tile location already occupied
     * by a tile in the specified TileList 'otherTiles'.
     * &lt;p&gt;
     * Checks if this Enemy is overlapping at least one tile in 'otherTiles'.
     * If it is, randomises its XY-coordinate within the map bounds and
     * rechecks until it is no longer overlapping any tiles.
     * 
     * @param otherTiles the TileList to be checked against for entrapping
     * this Enemy
     * 
     * @see GameObject#randomiseXY()
     * @see Entity#isOverlapping(GameObject)
     */
    public void checkIfIsStuckInside(TileList otherTiles) {

<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (isOverlapping(otherTiles)) {</span>
<span class="nc" id="L134">            randomiseXY();</span>
<span class="nc" id="L135">            checkIfIsStuckInside(otherTiles);</span>
        }
<span class="nc" id="L137">    }</span>

    /**
     * Retrieves the tile collided by this Enemy.
     * 
     * @return the collided tile
     */
    public Tile getCollidedTile() {

<span class="fc" id="L146">        return collidedTile;</span>
    }

    /**
     * Retrieves the Enemy's current movement.
     * 
     * @return the current movement
     */
    public Movement getMovement() {

<span class="fc" id="L156">        return movement;</span>
    }

    /**
     * Checks if this Enemy has collided with one of the tiles specified in
     * the specified TileList 'otherTiles'.
     * &lt;p&gt;
     * This method checks whether a collidedTile has been found (i.e, is not
     * null) and, if it has, whether it shares the same name as the name of
     * the tiles in 'otherTiles'.
     * 
     * @param otherTiles the TileList to be checked against for collision
     * @return true if this Enemy has collided with a tile in 'otherTiles'
     */
    public boolean hasCollidedWith(TileList otherTiles) {

<span class="nc bnc" id="L172" title="All 2 branches missed.">        return (collidedTile != null &amp;&amp;</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                collidedTile.getName() == otherTiles.getTileName());</span>
    }

    /**
     * Initialises the direction of movement of this Enemy at spawn.
     * &lt;p&gt;
     * Allocates each direction of movement to an integer from 0 to 3.
     * Then, retrieves a random integer from 0 and to 3 and sets this
     * Enemy's direction of movement accordingly.
     * 
     * @see GameObject#rand
     */
    public void initialiseMovement() {
        
<span class="fc" id="L187">        int randomiser = rand.nextInt(4);</span>

<span class="pc bpc" id="L189" title="1 of 5 branches missed.">        switch (randomiser) {</span>

            case 0:
<span class="fc" id="L192">                movement = Movement.UPLEFT;</span>
<span class="fc" id="L193">                break;</span>
            case 1:
<span class="fc" id="L195">                movement = Movement.UPRIGHT;</span>
<span class="fc" id="L196">                break;</span>
            case 2:
<span class="fc" id="L198">                movement = Movement.DOWNLEFT;</span>
<span class="fc" id="L199">                break;</span>
            case 3:
<span class="fc" id="L201">                movement = Movement.DOWNRIGHT;</span>
<span class="fc" id="L202">                break;</span>
            default:
<span class="nc" id="L204">                movement = Movement.STATIONARY;</span>
                break;
        }
<span class="fc" id="L207">    }</span>

    /**
     * Processes the movement of this Enemy each frame.
     * &lt;p&gt;
     * Off-bounds movement is first checked. The direction of movement
     * is modified accordingly to the direction of collision. Then, the
     * Enemy's XY-coordinate is modified accordingly to the direction of
     * movement.
     * 
     * @see #checkForOffMapMovement()
     * @see Entity#move()
     * @see Movement#flipHorizontally()
     * @see Movement#flipVertically()
     */
    @Override
    public void move() {

<span class="fc" id="L225">        checkForOffMapMovement();</span>

<span class="pc bpc" id="L227" title="6 of 7 branches missed.">        switch (collidedAt) {</span>
            
            case TOP:
            case BOTTOM:
<span class="fc" id="L231">                movement = movement.flipVertically();</span>
<span class="fc" id="L232">                break;</span>
            
            case LEFT:
            case RIGHT:
<span class="nc" id="L236">                movement = movement.flipHorizontally();</span>
<span class="nc" id="L237">                break;</span>
            
            case TOPLEFT:
<span class="nc" id="L240">                movement = Movement.UPLEFT;</span>
<span class="nc" id="L241">                break;</span>
            
            case BOTTOMLEFT:
<span class="nc" id="L244">                movement = Movement.DOWNLEFT;</span>
<span class="nc" id="L245">                break;</span>
        
            case TOPRIGHT:
<span class="nc" id="L248">                movement = Movement.UPRIGHT;</span>
<span class="nc" id="L249">                break;</span>
            
            case BOTTOMRIGHT:
<span class="nc" id="L252">                movement = Movement.DOWNRIGHT;</span>
<span class="nc" id="L253">                break;</span>
            
            default:
                break;
        }
<span class="fc" id="L258">        collidedAt = Side.NONE;</span>
<span class="fc" id="L259">        collidedTile = null;</span>

<span class="pc bpc" id="L261" title="4 of 5 branches missed.">        switch (movement) {</span>

            case UPLEFT:
<span class="nc" id="L264">                y -= 1;</span>
<span class="nc" id="L265">                x -= 1;</span>
<span class="nc" id="L266">                break;</span>
            case UPRIGHT:
<span class="nc" id="L268">                y -= 1;</span>
<span class="nc" id="L269">                x += 1;</span>
<span class="nc" id="L270">                break;</span>
            case DOWNLEFT:
<span class="nc" id="L272">                y += 1;</span>
<span class="nc" id="L273">                x -= 1;</span>
<span class="nc" id="L274">                break;</span>
            case DOWNRIGHT:
<span class="fc" id="L276">                y += 1;</span>
<span class="fc" id="L277">                x += 1;</span>
<span class="fc" id="L278">                break;</span>
            case STATIONARY:
                break;
        }
<span class="fc" id="L282">    }</span>

    /**
     * Sets this Enemy's movement to the specified movement.
     * 
     * @param movement the movement to be set to this Enemy
     */
    public void setMovement(Movement movement) {

<span class="fc" id="L291">        this.movement = movement;</span>
<span class="fc" id="L292">    }</span>

    /**
     * Checks if this Enemy has moved off the map bounds and applies
     * the appropriate actions.
     * 
     * @see Entity#checkForOffMapMovement()
     */
    @Override
    protected void checkForOffMapMovement() {

<span class="fc" id="L303">        int maxWidth = (Info.WIDTH - 2*SIZE);</span>
<span class="fc" id="L304">        int maxHeight = (Info.HEIGHT - 2*SIZE);</span>

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (x &lt; SIZE)</span>
<span class="nc" id="L307">            x = SIZE;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        else if (x &gt; maxWidth)</span>
<span class="nc" id="L309">            x = maxWidth;</span>
        
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (y &lt; Info.TOPBAR + SIZE)</span>
<span class="nc" id="L312">            y = Info.TOPBAR + SIZE;</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        else if (y &gt; maxHeight)</span>
<span class="nc" id="L314">            y = maxHeight;</span>
<span class="fc" id="L315">    }</span>

    /**
     * Checks whether this Enemy is overlapping on the horizontal axis with
     * the specified 'other' GameObject.
     * 
     * @param other the GameObject to be checked against for overlap
     * @return true if this Enemy overlaps on the horizontal axis with 'other'
     * 
     * @see Entity#isOverlappingHorizontally(GameObject)
     */
    @Override
    protected boolean isOverlappingHorizontally(GameObject other) {

<span class="fc bfc" id="L329" title="All 4 branches covered.">        return ((other.getX() - SIZE) &lt;= x &amp;&amp; x &lt;= (other.getX() + SIZE));</span>
    }

    /**
     * Checks whether this Enemy is overlapping on the vertical axis with
     * the specified 'other' GameObject.
     * 
     * @param other the GameObject to be checked against for overlap
     * @return true if this Enemy overlaps on the vertical axis with 'other'
     * 
     * @see Entity#isOverlappingVertically(GameObject)
     */
    @Override
    protected boolean isOverlappingVertically(GameObject other) {

<span class="pc bpc" id="L344" title="1 of 4 branches missed.">        return ((other.getY() - SIZE) &lt;= y &amp;&amp; y &lt;= (other.getY() + SIZE));</span>
    }

    /**
     * Checks whether this Enemy has collided off the corner of a tile
     * in the specified TileList 'otherTiles'.
     * &lt;p&gt;
     * If this Enemy has collided off a given corner of 'tile', also
     * checks if there are adjacent tiles in the given directions. If there
     * are none, updates this Enemy's collidedTile and collidedAt.
     * 
     * @param otherTiles the TileList to be checked against for diagonal
     * collision
     * 
     * @see #collidesAtBottomLeftWith(Tile, TileList)
     * @see #collidesAtBottomRightWith(Tile, TileList)
     * @see #collidesAtTopLeftWith(Tile, TileList)
     * @see #collidesAtTopRightWith(Tile, TileList)
     * @see Tile#getAdjacentTile(Direction)
     */
    private void checkForDiagonalCollisionWith(TileList otherTiles) {

<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (Tile tile : otherTiles.toList()) {</span>

<span class="fc" id="L368">            Tile top = tile.getAdjacentTile(Direction.UP);</span>
<span class="fc" id="L369">            Tile bottom = tile.getAdjacentTile(Direction.DOWN);</span>
<span class="fc" id="L370">            Tile left = tile.getAdjacentTile(Direction.LEFT);</span>
<span class="fc" id="L371">            Tile right = tile.getAdjacentTile(Direction.RIGHT);</span>
            
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if (collidesAtTopLeftWith(tile) &amp;&amp;</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">                !otherTiles.contains(top) &amp;&amp; !otherTiles.contains(left)) {</span>
                
<span class="nc" id="L376">                collidedTile = tile;</span>
<span class="nc" id="L377">                collidedAt = Side.TOPLEFT;</span>
            }
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            else if (collidesAtTopRightWith(tile) &amp;&amp;</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">                !otherTiles.contains(top) &amp;&amp; !otherTiles.contains(right)) {</span>
                
<span class="nc" id="L382">                collidedTile = tile;</span>
<span class="nc" id="L383">                collidedAt = Side.BOTTOMLEFT;</span>
            }
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            else if (collidesAtBottomLeftWith(tile) &amp;&amp;</span>
<span class="nc bnc" id="L386" title="All 4 branches missed.">                !otherTiles.contains(bottom) &amp;&amp; !otherTiles.contains(left)) {</span>
                
<span class="nc" id="L388">                collidedTile = tile;</span>
<span class="nc" id="L389">                collidedAt = Side.TOPRIGHT;</span>
            }
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">            else if (collidesAtBottomRightWith(tile) &amp;&amp;</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">                !otherTiles.contains(bottom) &amp;&amp; !otherTiles.contains(right)) {</span>
                
<span class="nc" id="L394">                collidedTile = tile;</span>
<span class="nc" id="L395">                collidedAt = Side.BOTTOMRIGHT;</span>
            }
<span class="fc" id="L397">        }</span>
<span class="fc" id="L398">    }</span>

    /**
     * Checks whether this Enemy has collided off the side of a tile
     * in the specified TileList 'otherTiles'.
     * &lt;p&gt;
     * For each tile in 'otherTiles', checks whether this Enemy has
     * collided with a tile in each of the four possible sides. If it
     * has collided with a tile at a given side, also checks whether
     * there is an adjacent tile on the opposite side. If there is
     * none, updates this Enemy's collidedTile and collidedAt.
     * 
     * @param otherTiles the TileList to be checked against for straight
     * collision
     * 
     * @see #collidesAtBottomWith(Tile)
     * @see #collidesAtLeftWith(Tile)
     * @see #collidesAtRightWith(Tile)
     * @see #collidesAtTopWith(Tile)
     * @see Tile#getAdjacentTile(Direction)
     */
    private void checkForStraightCollisionWith(TileList otherTiles) {

<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (Tile tile : otherTiles.toList()) {</span>

<span class="fc" id="L423">            Tile top = tile.getAdjacentTile(Direction.UP);</span>
<span class="fc" id="L424">            Tile bottom = tile.getAdjacentTile(Direction.DOWN);</span>
<span class="fc" id="L425">            Tile left = tile.getAdjacentTile(Direction.LEFT);</span>
<span class="fc" id="L426">            Tile right = tile.getAdjacentTile(Direction.RIGHT);</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (collidesAtTopWith(tile) &amp;&amp;</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">                !otherTiles.contains(bottom)) {</span>

<span class="fc" id="L431">                collidedTile = tile;</span>
<span class="fc" id="L432">                collidedAt = Side.TOP;</span>
            }
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            else if (collidesAtBottomWith(tile) &amp;&amp;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                !otherTiles.contains(top)) {</span>

<span class="nc" id="L437">                collidedTile = tile;</span>
<span class="nc" id="L438">                collidedAt = Side.BOTTOM;</span>
            }
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            else if (collidesAtLeftWith(tile) &amp;&amp;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                !otherTiles.contains(right)) {</span>

<span class="nc" id="L443">                collidedTile = tile;</span>
<span class="nc" id="L444">                collidedAt = Side.LEFT;</span>
            }
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            else if (collidesAtRightWith(tile) &amp;&amp;</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">                !otherTiles.contains(left)) {</span>

<span class="fc" id="L449">                collidedTile = tile;</span>
<span class="fc" id="L450">                collidedAt = Side.RIGHT;</span>
            }
<span class="fc" id="L452">        }</span>
<span class="fc" id="L453">    }</span>

    /**
     * Checks if this Enemy has collided off the top left corner of a
     * tile.
     * &lt;p&gt;
     * For a top-left collision to be possible, this Enemy must firstly
     * be moving in the down-right direction. If it is and it is at the
     * appropriate XY-coordinate in relation to the tile's XY-coordinate,
     * return true.
     * 
     * @param tile the Tile to be checked against for top-left collision
     * @param otherTiles the TileList to be checked against for adjacency
     * @return true if this Enemy has collided off the top-left corner
     * of 'tile'
     */
    private boolean collidesAtTopLeftWith(Tile tile) {

<span class="fc bfc" id="L471" title="All 2 branches covered.">        return (movement == Movement.DOWNRIGHT &amp;&amp;</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">                getMidX() == (tile.getMidX() - SIZE) &amp;&amp;</span>
<span class="pc bnc" id="L473" title="All 2 branches missed.">                getMidY() == (tile.getMidY() - SIZE));</span>
    }

    /**
     * Checks if this Enemy has collided off the top right corner of a
     * tile.
     * &lt;p&gt;
     * For a top-right collision to be possible, this Enemy must firstly
     * be moving in the down-left direction. If it is and it is at the
     * appropriate XY-coordinate in relation to the tile's XY-coordinate,
     * return true.
     * 
     * @param tile the Tile to be checked against for top-right collision
     * @param otherTiles the TileList to be checked against for adjacency
     * @return true if this Enemy has collided off the top-right corner
     * of 'tile'
     */
    private boolean collidesAtTopRightWith(Tile tile) {

<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        return (movement == Movement.DOWNLEFT &amp;&amp;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                getMidX() == (tile.getMidX() + SIZE) &amp;&amp;</span>
<span class="pc bnc" id="L494" title="All 2 branches missed.">                getMidY() == (tile.getMidY() - SIZE));</span>
    }

    /**
     * Checks if this Enemy has collided off the bottom left corner of a
     * tile.
     * &lt;p&gt;
     * For a bottom-left collision to be possible, this Enemy must firstly
     * be moving in the up-right direction. If it is and it is at the
     * appropriate XY-coordinate in relation to the tile's XY-coordinate,
     * return true.
     * 
     * @param tile the Tile to be checked against for bottom-left collision
     * @param otherTiles the TileList to be checked against for adjacency
     * @return true if this Enemy has collided off the bottom-left corner
     * of 'tile'
     */
    private boolean collidesAtBottomLeftWith(Tile tile) {

<span class="fc bfc" id="L513" title="All 2 branches covered.">        return (movement == Movement.UPRIGHT &amp;&amp;</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                getMidX() == (tile.getMidX() - SIZE) &amp;&amp;</span>
<span class="pc bnc" id="L515" title="All 2 branches missed.">                getMidY() == (tile.getMidY() + SIZE));</span>
    }

    /**
     * Checks if this Enemy has collided off the bottom right corner of a
     * tile.
     * &lt;p&gt;
     * For a bottom-right collision to be possible, this Enemy must firstly
     * be moving in the up-left direction. If it is and it is at the
     * appropriate XY-coordinate in relation to the tile's XY-coordinate,
     * return true.
     * 
     * @param tile the Tile to be checked against for bottom-right collision
     * @param otherTiles the TileList to be checked against for adjacency
     * @return true if this Enemy has collided off the bottom-right corner
     * of 'tile'
     */
    private boolean collidesAtBottomRightWith(Tile tile) {

<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        return (movement == Movement.UPLEFT &amp;&amp;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                getMidX() == (tile.getMidX() + SIZE) &amp;&amp;</span>
<span class="pc bnc" id="L536" title="All 2 branches missed.">                getMidY() == (tile.getMidY() + SIZE));</span>
    }

    /**
     * Checks if this Enemy off the top side of a tile.
     * &lt;p&gt;
     * The vertical distance between this Enemy and 'tile' is calculated.
     * If this vertical distance lies between 0 and 1, and it is overlapping
     * on the horizontal axis with the same tile, returns true. Recalibrates
     * this Enemy's y-coordinate if needed.
     * 
     * @param tile the Tile to be checked against for top collision
     * @return true if this Enemy has collided off the top side of 'tile'.
     * 
     * @see #isOverlappingHorizontally(GameObject)
     */
    private boolean collidesAtTopWith(Tile tile) {

<span class="fc" id="L554">        int distY = SIZE - (y - tile.getY());</span>

<span class="pc bpc" id="L556" title="2 of 6 branches missed.">        if (isOverlappingHorizontally(tile) &amp;&amp; (0 &lt;= distY &amp;&amp; distY &lt;= 1)) {</span>
<span class="fc" id="L557">            y = tile.getY() + SIZE;</span>
<span class="fc" id="L558">            return true;</span>
        }
<span class="fc" id="L560">        return false;</span>
    }

    /**
     * Checks if this Enemy off the bottom side of a tile.
     * &lt;p&gt;
     * The vertical distance between this Enemy and 'tile' is calculated.
     * If this vertical distance lies between 0 and 1, and it is overlapping
     * on the horizontal axis with the same tile, returns true. Recalibrates
     * this Enemy's y-coordinate if needed.
     * 
     * @param tile the Tile to be checked against for bottom collision
     * @return true if this Enemy has collided off the bottom side of 'tile'.
     * 
     * @see #isOverlappingHorizontally(GameObject)
     */
    private boolean collidesAtBottomWith(Tile tile) {
        
<span class="fc" id="L578">        int distY = SIZE - (tile.getY() - y);</span>

<span class="pc bpc" id="L580" title="3 of 6 branches missed.">        if (isOverlappingHorizontally(tile) &amp;&amp; (0 &lt;= distY &amp;&amp; distY &lt;= 1)) {</span>
<span class="nc" id="L581">            y = tile.getY() - SIZE;</span>
<span class="nc" id="L582">            return true;</span>
        }
<span class="fc" id="L584">        return false;</span>
    }

    /**
     * Checks if this Enemy off the left side of a tile.
     * &lt;p&gt;
     * The horizontal distance between this Enemy and 'tile' is calculated.
     * If this horizontal distance lies between 0 and 1, and it is overlapping
     * on the vertical axis with the same tile, returns true. Recalibrates
     * this Enemy's x-coordinate if needed.
     * 
     * @param tile the Tile to be checked against for left collision
     * @return true if this Enemy has collided off the left side of 'tile'.
     * 
     * @see #isOverlappingVertically(GameObject)
     */
    private boolean collidesAtLeftWith(Tile tile) {

<span class="fc" id="L602">        int distX = SIZE - (x - tile.getX());</span>

<span class="pc bpc" id="L604" title="4 of 6 branches missed.">        if ((0 &lt;= distX &amp;&amp; distX &lt;= 1) &amp;&amp; isOverlappingVertically(tile)) {</span>
<span class="nc" id="L605">            x = tile.getX() + SIZE;</span>
<span class="nc" id="L606">            return true;</span>
        }
<span class="fc" id="L608">        return false;</span>
    }

    /**
     * Checks if this Enemy off the right side of a tile.
     * &lt;p&gt;
     * The horizontal distance between this Enemy and 'tile' is calculated.
     * If this horizontal distance lies between 0 and 1, and it is overlapping
     * on the vertical axis with the same tile, returns true. Recalibrates
     * this Enemy's x-coordinate if needed.
     * 
     * @param tile the Tile to be checked against for right collision
     * @return true if this Enemy has collided off the right side of 'tile'.
     * 
     * @see #isOverlappingVertically(GameObject)
     */
    private boolean collidesAtRightWith(Tile tile) {

<span class="fc" id="L626">        int distX = SIZE - (tile.getX() - x);</span>

<span class="pc bpc" id="L628" title="3 of 6 branches missed.">        if ((0 &lt;= distX &amp;&amp; distX &lt;= 1) &amp;&amp; isOverlappingVertically(tile)) {</span>
<span class="fc" id="L629">            x = tile.getX() - SIZE;</span>
<span class="fc" id="L630">            return true;</span>
        }
<span class="nc" id="L632">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>